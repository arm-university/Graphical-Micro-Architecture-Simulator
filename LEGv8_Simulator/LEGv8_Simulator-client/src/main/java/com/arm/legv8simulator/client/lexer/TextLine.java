package com.arm.legv8simulator.client.lexer;

import java.util.ArrayList;

import com.arm.legv8simulator.client.instruction.Mnemonic;
import com.arm.legv8simulator.client.parser.Parser;

/**
 * The <code>TextLine</code> class is used to manipulate a line of LEGv8 source code.
 * <p>
 * Operations include: 
 * <ul>
 * 	<li> Invoking the <code>Lexer</code> and <code>Parser</code>
 * 	<li> Code formatting
 * </ul>
 * 
 * @author Jonathan Wright, 2016
 */
public class TextLine {

	/**
	 * @param line	a line of LEGv8 source code from the text editor
	 */
	public TextLine(String line) {
		this.line = line;
		removeComment();
	}
	
	private void removeComment() {
		int commentIdentifierIndex = line.indexOf("//");
		if (commentIdentifierIndex != -1) {
			comment = line.substring(commentIdentifierIndex);
			lineNoComment = line.substring(0, commentIdentifierIndex);
		} else {
			lineNoComment = line;
		}
	}
	
	/**
	 * Invokes the <code>Lexer</code> on the line of source code to produce a list of tokens
	 * 
	 * @see Lexer
	 */
	public void tokenize() {
		tokens = Lexer.lex(lineNoComment);
	}
	
	/**
	 * Invokes the <code>Parser</code> on the list of tokens generated by the <code>Lexer</code>
	 * 
	 * @return	the error message from the <code>Parser</code>; <code>null</code> if no error present.
	 */
	public String parse() {
		String error = Parser.parseLine(tokens);
		parsed = (error == null);
		if (parsed) {
			decodeLine();
		}
		return error;
	}

	/*
	 * Called only when line parsed correctly
	 * Used to set each of the label, mnemonic, args and comment fields
	 */
	private void decodeLine() {
		for (Token t : tokens) {
			switch (t.getType()) {
			case WHITESPACE : break;
			case COMMA : break;
			case LBRACKET : break;
			case RBRACKET : break;
			case LABEL : label = t.getData().substring(0, t.getData().length()-1); break;
			case REGISTER : args.add(t.getData()); break;
			case IMMEDIATE : args.add(t.getData()); break;
			case IDENTIFIER : args.add(t.getData()); break;
			// following case should never occur - parser never accepts ERROR tokens
			case ERROR : comment += "something has gone very wrong for this to happen!"; break;
			default : 
				if (mnemonic == null) {
					mnemonic = Mnemonic.fromString(t.getData().trim());
					mneType = t.getType();
				} else {
					args.add(t.getData().trim());
				}
			}
		}
	}
	
	/**
	 * @return the formatted line of LEGv8 source code. If the code could not be parsed, 
	 * it will be returned as entered.
	 */
	public String getLine() {
		if (!parsed) {
			return this.line;
		}
		String line = "";
		if (label != null) { 
			line += label + ":";
		}
		if (mnemonic != null) {
			line += "\t" + mnemonic.nameUpper + "\t";
		}
		if (args.size() != 0) {
			line += formatArgs();
		}
		if (line.isEmpty()) {
			return this.line;
		} else {
			if (comment != null) {
				line += "\t" + comment;
			}
		}
		return line;
	}
	
	/*
	 * Returns a string containing the instruction arguments appropriately formatted
	 * Format type is dictated by the instruction group
	 * See LEGv8_Grammar.ppt slides for description of instruction groups
	 */
	private String formatArgs() {
		switch (mneType) {
		case MNEMONIC_R : 
			return formatRArgs();
		case MNEMONIC_RR : 
			return formatRRArgs();
		case MNEMONIC_RRR : 
			return formatRRRArgs();
		case MNEMONIC_RI : 
			return formatRIArgs();
		case MNEMONIC_RRI : 
			return formatRRIArgs();
		case MNEMONIC_RM : 
			return formatRMArgs();
		case MNEMONIC_RRM : 
			return formatRRMArgs();
		case MNEMONIC_RISI : 
			return formatRISIArgs();
		case MNEMONIC_L : 
			return formatLArgs();
		case MNEMONIC_RL : 
			return formatRLArgs();
		default : return "Args formatting Failed.";
		}
	}
	
	private String formatRArgs() {
		return args.get(0);
	}
	
	private String formatRRArgs() {
		return args.get(0) + ", " + args.get(1);
	}
	
	private String formatRRRArgs() {
		return args.get(0) + ", " + args.get(1) + ", " + args.get(2);
	}
	
	private String formatRIArgs() {
		return args.get(0) + ", " + args.get(1);
	}
	
	private String formatRRIArgs() {
		return args.get(0) + ", " + args.get(1) + ", " + args.get(2);
	}
	
	private String formatRMArgs() {
		if (args.size() == 2) {
			return args.get(0) + ", [" + args.get(1) + "]";
		} else {
			return args.get(0) + ", [" + args.get(1) + ", " + args.get(2) + "]";
		}
	}
	
	private String formatRRMArgs() {
		if (args.size() == 3) {
			return args.get(0) + ", " + args.get(1) + ", [" + args.get(2) + "]";
		} else {
			return args.get(0) + ", " + args.get(1) + ", [" + args.get(2) + ", " + args.get(3) + "]";
		}
	}
	
	private String formatRISIArgs() {
		if (args.size() == 2) {
			return args.get(0) + ", " + args.get(1);
		} else {
			return args.get(0) + ", " + args.get(1) + ", LSL " + args.get(3);
		}
	}
	
	private String formatLArgs() {
		return args.get(0);
	}
	
	private String formatRLArgs() {
		return args.get(0) + ", " + args.get(1);
	}
	
	/**
	 * 
	 * @return	the label prefixing the instruction; <code>null</code> if none found
	 */
	public String getLabel() {
		return label;
	}
	
	/**
	 * 
	 * @return	the instruction mnemonic; <code>null</code> if none found
	 */
	public Mnemonic getMnemonic() {
		return mnemonic;
	}
	
	/**
	 * 
	 * @return	the list of instruction arguments; <code>null</code> if none found
	 */
	public ArrayList<String> getArgs() {
		return args;
	}
	
	/**
	 * Useful to see the output from the <code>Lexer</code>
	 * 
	 * @return the tokens in this <code>TextLine</code> object; each on a separate line
	 */
	public String getTokens() {
		String s = "";
		for (Token t: tokens) {
			s += t.toString() + "\n";
		}
		return s;
	}
	
	/**
	 * @return the number of lexical tokens found in this line of source code
	 */
	public int getNumTokens() {
		if (tokens == null) {
			return 0;
		} else {
			return tokens.size();
		}
	}
	
	private boolean parsed = false;
	private String line;
	private String lineNoComment;
	private ArrayList<Token> tokens = new ArrayList<Token>();
	private String label = null;
	private TokenType mneType = null;
	private Mnemonic mnemonic = null;
	private ArrayList<String> args = new ArrayList<String>();
	private String comment = null;
}
